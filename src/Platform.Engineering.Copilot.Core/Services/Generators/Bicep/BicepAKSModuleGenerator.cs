using System.Text;
using System.Linq;
using System.Collections.Generic;
using Platform.Engineering.Copilot.Core.Models;

namespace Platform.Engineering.Copilot.Core.Services.Generators.Bicep;

/// <summary>
/// Generates Azure Kubernetes Service (AKS) Bicep module files
/// Implements Azure best practices including Workload Identity, Azure CNI, and Azure Monitor
/// </summary>
public class BicepAKSModuleGenerator
{
    /// <summary>
    /// Generate complete AKS module with cluster, networking, identity, and monitoring
    /// </summary>
    public Dictionary<string, string> GenerateAKSModule(TemplateGenerationRequest request)
    {
        var files = new Dictionary<string, string>();
        var serviceName = request.ServiceName.ToLowerInvariant();
        var infrastructure = request.Infrastructure ?? new InfrastructureSpec();
        var deployment = request.Deployment ?? new DeploymentSpec();
        var security = request.Security ?? new SecuritySpec();
        var observability = request.Observability ?? new ObservabilitySpec();
        
        var modulePath = "modules/aks";
        
        // Generate module files
        files[$"{modulePath}/main.bicep"] = GenerateMainBicep(request);
        files[$"{modulePath}/cluster.bicep"] = GenerateClusterBicep(request);
        files[$"{modulePath}/network.bicep"] = GenerateNetworkBicep(request);
        files[$"{modulePath}/identity.bicep"] = GenerateIdentityBicep(request);
        files[$"{modulePath}/monitoring.bicep"] = GenerateMonitoringBicep(request);
        files[$"{modulePath}/security.bicep"] = GenerateSecurityBicep(request);
        files[$"{modulePath}/acr.bicep"] = GenerateACRBicep(request);
        files[$"{modulePath}/acr-private-endpoint.bicep"] = GenerateACRPrivateEndpointBicep(request);
        files[$"{modulePath}/parameters.json"] = GenerateParametersJson(request);
        files[$"{modulePath}/pod-security-policies.yaml"] = GeneratePodSecurityPolicies();
        files[$"{modulePath}/network-policies.yaml"] = GenerateNetworkPolicies();
        files[$"{modulePath}/azure-policy-assignments.bicep"] = GenerateAzurePolicyAssignments();
        
        return files;
    }
    
    private string GenerateMainBicep(TemplateGenerationRequest request)
    {
        var serviceName = request.ServiceName.ToLowerInvariant();
        
        return $@"// AKS Cluster Module - Main Entry Point
// Generated by Platform Engineering Copilot

targetScope = 'resourceGroup'

@description('Name of the service')
param serviceName string

@description('Environment (dev, staging, prod)')
param environment string

@description('Azure region')
param location string = resourceGroup().location

@description('Kubernetes version')
param kubernetesVersion string = '1.28'

@description('Enable Workload Identity')
param enableWorkloadIdentity bool = true

@description('Enable Azure Monitor')
param enableMonitoring bool = true

@description('Enable Azure Policy')
param enableAzurePolicy bool = true

@description('Enable Private Endpoint for ACR (recommended for Zero Trust)')
param enablePrivateEndpointACR bool = false

@description('Node pool size')
param nodeCount int = 3

@description('Node VM size')
param nodeVmSize string = 'Standard_D4s_v3'

var commonTags = {{
  Environment: environment
  Service: serviceName
  ManagedBy: 'bicep'
  Platform: 'AKS'
}}

// Network module
module network './network.bicep' = {{
  name: '${{serviceName}}-${{environment}}-network'
  params: {{
    serviceName: serviceName
    environment: environment
    location: location
    tags: commonTags
  }}
}}

// Identity module (Managed Identity + Workload Identity)
module identity './identity.bicep' = {{
  name: '${{serviceName}}-${{environment}}-identity'
  params: {{
    serviceName: serviceName
    environment: environment
    location: location
    enableWorkloadIdentity: enableWorkloadIdentity
    tags: commonTags
  }}
}}

// AKS Cluster
module cluster './cluster.bicep' = {{
  name: '${{serviceName}}-${{environment}}-cluster'
  params: {{
    serviceName: serviceName
    environment: environment
    location: location
    kubernetesVersion: kubernetesVersion
    nodeCount: nodeCount
    nodeVmSize: nodeVmSize
    subnetId: network.outputs.aksSubnetId
    identityId: identity.outputs.managedIdentityId
    enableWorkloadIdentity: enableWorkloadIdentity
    enableAzurePolicy: enableAzurePolicy
    tags: commonTags
  }}
}}

// Azure Container Registry
module acr './acr.bicep' = {{
  name: '${{serviceName}}-${{environment}}-acr'
  params: {{
    serviceName: serviceName
    environment: environment
    location: location
    clusterPrincipalId: cluster.outputs.kubeletIdentityObjectId
    enablePrivateEndpoint: enablePrivateEndpointACR
    tags: commonTags
  }}
}}

// ACR Private Endpoint (if enabled)
module acrPrivateEndpoint './acr-private-endpoint.bicep' = if (enablePrivateEndpointACR) {{
  name: '${{serviceName}}-${{environment}}-acr-pe'
  params: {{
    serviceName: serviceName
    environment: environment
    location: location
    acrResourceId: acr.outputs.acrResourceId
    subnetId: network.outputs.pesubnetSubnetId
    virtualNetworkId: network.outputs.vnetId
    tags: commonTags
  }}
  dependsOn: [
    acr
  ]
}}

// Security (Key Vault + Policies)
module security './security.bicep' = {{
  name: '${{serviceName}}-${{environment}}-security'
  params: {{
    serviceName: serviceName
    environment: environment
    location: location
    subnetId: network.outputs.aksSubnetId
    clusterPrincipalId: cluster.outputs.kubeletIdentityObjectId
    tags: commonTags
  }}
}}

// Monitoring (Log Analytics + Azure Monitor)
module monitoring './monitoring.bicep' = if (enableMonitoring) {{
  name: '${{serviceName}}-${{environment}}-monitoring'
  params: {{
    serviceName: serviceName
    environment: environment
    location: location
    clusterId: cluster.outputs.clusterId
    tags: commonTags
  }}
}}

// Outputs
output clusterId string = cluster.outputs.clusterId
output clusterName string = cluster.outputs.clusterName
output clusterFqdn string = cluster.outputs.clusterFqdn
output kubeletIdentityObjectId string = cluster.outputs.kubeletIdentityObjectId
output acrLoginServer string = acr.outputs.loginServer
output acrName string = acr.outputs.name
output vnetId string = network.outputs.vnetId
output keyVaultName string = security.outputs.keyVaultName
output workspaceId string = enableMonitoring ? monitoring.outputs.workspaceId : ''
";
    }
    
    private string GenerateClusterBicep(TemplateGenerationRequest request)
    {
        return @"// AKS Cluster Configuration - ZERO TRUST ARCHITECTURE
// Implements comprehensive Zero Trust security controls
// - Private API Server with authorized IP ranges
// - Pod Security Admission (restricted)
// - Image scanning and vulnerability assessment
// - Encryption at rest with customer-managed keys
// - Comprehensive audit logging
// - Network micro-segmentation
// - Runtime threat detection with Microsoft Defender

targetScope = 'resourceGroup'

param serviceName string
param environment string
param location string
param kubernetesVersion string
param nodeCount int
param nodeVmSize string
param subnetId string
param identityId string
param enableWorkloadIdentity bool
param enableAzurePolicy bool
param tags object

@description('Enable Private Cluster (recommended for Zero Trust)')
param enablePrivateCluster bool = true

@description('Authorized IP ranges for API server access (if not private)')
param authorizedIPRanges array = []

@description('Log Analytics Workspace ID for monitoring')
param logAnalyticsWorkspaceId string = ''

@description('Enable image cleaner')
param enableImageCleaner bool = true

@description('Disk encryption set ID for customer-managed keys')
param diskEncryptionSetId string = ''

var clusterName = '${serviceName}-${environment}-aks'

resource aksCluster 'Microsoft.ContainerService/managedClusters@2023-10-01' = {
  name: clusterName
  location: location
  tags: tags
  identity: {
    type: 'UserAssigned'
    userAssignedIdentities: {
      '${identityId}': {}
    }
  }
  sku: {
    name: 'Base'
    tier: 'Standard'
  }
  properties: {
    dnsPrefix: '${serviceName}-${environment}'
    kubernetesVersion: kubernetesVersion
    enableRBAC: true
    
    // Network Configuration (Azure CNI)
    networkProfile: {
      networkPlugin: 'azure'
      networkPolicy: 'azure'
      serviceCidr: '10.2.0.0/16'
      dnsServiceIP: '10.2.0.10'
      loadBalancerSku: 'standard'
      outboundType: 'loadBalancer'
    }
    
    // Default Node Pool (System)
    agentPoolProfiles: [
      {
        name: 'system'
        count: nodeCount
        vmSize: nodeVmSize
        mode: 'System'
        osType: 'Linux'
        osSKU: 'AzureLinux'
        vnetSubnetID: subnetId
        enableAutoScaling: true
        minCount: 2
        maxCount: 10
        maxPods: 110
        type: 'VirtualMachineScaleSets'
        availabilityZones: [
          '1'
          '2'
          '3'
        ]
        enableNodePublicIP: false
        tags: tags
      }
    ]
    
    // Azure AD Integration
    aadProfile: {
      managed: true
      enableAzureRBAC: true
      tenantID: subscription().tenantId
    }
    
    // ZERO TRUST: Workload Identity + Image Integrity + Encryption
    securityProfile: {
      workloadIdentity: {
        enabled: enableWorkloadIdentity
      }
      defender: {
        logAnalyticsWorkspaceResourceId: logAnalyticsWorkspaceId
        securityMonitoring: {
          enabled: true
        }
      }
      imageCleaner: {
        enabled: enableImageCleaner
        intervalHours: 168 // Weekly cleanup
      }
      // Pod Security Admission (replaces Pod Security Policy)
      // Enforces restricted pod security standards
      azurePolicyServerProfile: {
        enabled: enableAzurePolicy
      }
    }
    
    // Encryption at rest with customer-managed keys
    diskEncryptionSetID: !empty(diskEncryptionSetId) ? diskEncryptionSetId : null
    
    // OIDC Issuer (required for Workload Identity)
    oidcIssuerProfile: {
      enabled: enableWorkloadIdentity
    }
    
    // Auto-upgrade channel with node image upgrade
    autoUpgradeProfile: {
      upgradeChannel: 'stable'
      nodeOSUpgradeChannel: 'NodeImage' // Auto-update node images for security patches
    }
    
    // ZERO TRUST: Azure Policy + Key Vault + OMS Agent
    addonProfiles: {
      azurepolicy: {
        enabled: enableAzurePolicy
        config: {
          version: 'v2'
        }
      }
      azureKeyvaultSecretsProvider: {
        enabled: true
        config: {
          enableSecretRotation: 'true'
          rotationPollInterval: '2m'
        }
      }
      omsagent: !empty(logAnalyticsWorkspaceId) ? {
        enabled: true
        config: {
          logAnalyticsWorkspaceResourceID: logAnalyticsWorkspaceId
          useAADAuth: 'true'
        }
      } : {
        enabled: false
      }
    }
    
    // ZERO TRUST: Private API Server or Authorized IP Ranges
    apiServerAccessProfile: {
      enablePrivateCluster: enablePrivateCluster
      enablePrivateClusterPublicFQDN: enablePrivateCluster
      authorizedIPRanges: !enablePrivateCluster && length(authorizedIPRanges) > 0 ? authorizedIPRanges : []
      enableVnetIntegration: enablePrivateCluster
    }
    
    // HTTP Application Routing (DISABLED for security - use Ingress Controller)
    httpApplicationRoutingEnabled: false
    
    // ZERO TRUST: Disable local accounts (Azure AD only)
    disableLocalAccounts: true
    
    // Enable Azure RBAC for Kubernetes authorization
    enableRBAC: true
    
    // Storage profile with encrypted OS disks
    storageProfile: {
      diskCSIDriver: {
        enabled: true
        version: 'v1'
      }
      fileCSIDriver: {
        enabled: true
      }
      snapshotController: {
        enabled: true
      }
    }
    
    // Support plan (for production workloads)
    supportPlan: environment == 'prod' ? 'AKSLongTermSupport' : 'KubernetesOfficial'
  }
}

// User Node Pool (Application workloads)
resource userNodePool 'Microsoft.ContainerService/managedClusters/agentPools@2023-10-01' = {
  parent: aksCluster
  name: 'user'
  properties: {
    count: nodeCount
    vmSize: nodeVmSize
    mode: 'User'
    osType: 'Linux'
    osSKU: 'AzureLinux'
    vnetSubnetID: subnetId
    enableAutoScaling: true
    minCount: 1
    maxCount: 20
    maxPods: 110
    type: 'VirtualMachineScaleSets'
    availabilityZones: [
      '1'
      '2'
      '3'
    ]
    enableNodePublicIP: false
    tags: union(tags, {
      NodePool: 'user'
      Workload: 'application'
    })
  }
}

output clusterId string = aksCluster.id
output clusterName string = aksCluster.name
output clusterFqdn string = aksCluster.properties.fqdn
output kubeletIdentityObjectId string = aksCluster.properties.identityProfile.kubeletidentity.objectId
output oidcIssuerUrl string = enableWorkloadIdentity ? aksCluster.properties.oidcIssuerProfile.issuerURL : ''
";
    }
    
    private string GenerateNetworkBicep(TemplateGenerationRequest request)
    {
        var infrastructure = request.Infrastructure ?? new InfrastructureSpec();
        var networkConfig = infrastructure.NetworkConfig ?? CreateDefaultAKSNetworkConfig();
        
        // Check if using existing network or creating new
        if (networkConfig.Mode == NetworkMode.UseExisting)
        {
            return GenerateExistingNetworkReferencesBicep(networkConfig);
        }
        
        var sb = new StringBuilder();
        
        sb.AppendLine("// Virtual Network Configuration for AKS");
        sb.AppendLine("// Implements network isolation with dedicated subnets");
        sb.AppendLine();
        sb.AppendLine("targetScope = 'resourceGroup'");
        sb.AppendLine();
        sb.AppendLine("param serviceName string");
        sb.AppendLine("param environment string");
        sb.AppendLine("param location string");
        sb.AppendLine("param tags object");
        sb.AppendLine();
        
        // VNet parameters
        sb.AppendLine($"@description('Virtual Network name')");
        sb.AppendLine($"param vnetName string = '{networkConfig.VNetName}'");
        sb.AppendLine();
        sb.AppendLine($"@description('Virtual Network address space')");
        sb.AppendLine($"param vnetAddressSpace string = '{networkConfig.VNetAddressSpace}'");
        sb.AppendLine();
        
        // DDoS Protection (if enabled)
        if (networkConfig.EnableDDoSProtection)
        {
            sb.AppendLine("@description('Enable DDoS Protection')");
            sb.AppendLine($"param enableDDoSProtection bool = {networkConfig.EnableDDoSProtection.ToString().ToLower()}");
            sb.AppendLine();
            if (!string.IsNullOrEmpty(networkConfig.DDoSProtectionPlanId))
            {
                sb.AppendLine("@description('DDoS Protection Plan ID')");
                sb.AppendLine($"param ddosProtectionPlanId string = '{networkConfig.DDoSProtectionPlanId}'");
                sb.AppendLine();
            }
        }
        
        // Virtual Network
        sb.AppendLine("// Virtual Network");
        sb.AppendLine("resource vnet 'Microsoft.Network/virtualNetworks@2023-05-01' = {");
        sb.AppendLine("  name: vnetName");
        sb.AppendLine("  location: location");
        sb.AppendLine("  tags: tags");
        sb.AppendLine("  properties: {");
        sb.AppendLine("    addressSpace: {");
        sb.AppendLine("      addressPrefixes: [vnetAddressSpace]");
        sb.AppendLine("    }");
        
        if (networkConfig.EnableDDoSProtection && !string.IsNullOrEmpty(networkConfig.DDoSProtectionPlanId))
        {
            sb.AppendLine("    enableDdosProtection: enableDDoSProtection");
            sb.AppendLine("    ddosProtectionPlan: {");
            sb.AppendLine("      id: ddosProtectionPlanId");
            sb.AppendLine("    }");
        }
        
        // Subnets array
        sb.AppendLine("    subnets: [");
        foreach (var subnet in networkConfig.Subnets)
        {
            sb.AppendLine("      {");
            sb.AppendLine($"        name: '{subnet.Name}'");
            sb.AppendLine("        properties: {");
            sb.AppendLine($"          addressPrefix: '{subnet.AddressPrefix}'");
            sb.AppendLine("          privateEndpointNetworkPolicies: 'Disabled'");
            
            if (!string.IsNullOrEmpty(subnet.Delegation))
            {
                sb.AppendLine("          privateLinkServiceNetworkPolicies: 'Enabled'");
            }
            
            if (subnet.EnableServiceEndpoints && subnet.ServiceEndpoints.Any())
            {
                sb.AppendLine("          serviceEndpoints: [");
                foreach (var endpoint in subnet.ServiceEndpoints)
                {
                    sb.AppendLine("            {");
                    sb.AppendLine($"              service: '{endpoint}'");
                    sb.AppendLine("            }");
                }
                sb.AppendLine("          ]");
            }
            
            sb.AppendLine("        }");
            sb.AppendLine("      }");
        }
        sb.AppendLine("    ]");
        
        sb.AppendLine("  }");
        sb.AppendLine("}");
        sb.AppendLine();
        
        // Network Security Group (if enabled)
        if (networkConfig.EnableNetworkSecurityGroup)
        {
            sb.AppendLine("// Network Security Group for AKS Subnet");
            sb.AppendLine("resource aksNsg 'Microsoft.Network/networkSecurityGroups@2023-05-01' = {");
            sb.AppendLine("  name: '${vnetName}-aks-nsg'");
            sb.AppendLine("  location: location");
            sb.AppendLine("  tags: tags");
            sb.AppendLine("  properties: {");
            sb.AppendLine("    securityRules: [");
            
            if (networkConfig.NsgRules.Any())
            {
                foreach (var rule in networkConfig.NsgRules)
                {
                    sb.AppendLine("      {");
                    sb.AppendLine($"        name: '{rule.Name}'");
                    sb.AppendLine("        properties: {");
                    sb.AppendLine($"          protocol: '{rule.Protocol}'");
                    sb.AppendLine($"          sourcePortRange: '{rule.SourcePortRange}'");
                    sb.AppendLine($"          destinationPortRange: '{rule.DestinationPortRange}'");
                    sb.AppendLine($"          sourceAddressPrefix: '{rule.SourceAddressPrefix}'");
                    sb.AppendLine($"          destinationAddressPrefix: '{rule.DestinationAddressPrefix}'");
                    sb.AppendLine($"          access: '{rule.Access}'");
                    sb.AppendLine($"          priority: {rule.Priority}");
                    sb.AppendLine($"          direction: '{rule.Direction}'");
                    sb.AppendLine($"          description: '{rule.Description}'");
                    sb.AppendLine("        }");
                    sb.AppendLine("      }");
                }
            }
            else
            {
                // Default rules for AKS
                sb.AppendLine("      {");
                sb.AppendLine("        name: 'AllowHttpsInbound'");
                sb.AppendLine("        properties: {");
                sb.AppendLine("          protocol: 'Tcp'");
                sb.AppendLine("          sourcePortRange: '*'");
                sb.AppendLine("          destinationPortRange: '443'");
                sb.AppendLine("          sourceAddressPrefix: 'Internet'");
                sb.AppendLine("          destinationAddressPrefix: '*'");
                sb.AppendLine("          access: 'Allow'");
                sb.AppendLine("          priority: 100");
                sb.AppendLine("          direction: 'Inbound'");
                sb.AppendLine("        }");
                sb.AppendLine("      }");
                sb.AppendLine("      {");
                sb.AppendLine("        name: 'AllowHttpInbound'");
                sb.AppendLine("        properties: {");
                sb.AppendLine("          protocol: 'Tcp'");
                sb.AppendLine("          sourcePortRange: '*'");
                sb.AppendLine("          destinationPortRange: '80'");
                sb.AppendLine("          sourceAddressPrefix: 'Internet'");
                sb.AppendLine("          destinationAddressPrefix: '*'");
                sb.AppendLine("          access: 'Allow'");
                sb.AppendLine("          priority: 110");
                sb.AppendLine("          direction: 'Inbound'");
                sb.AppendLine("        }");
                sb.AppendLine("      }");
            }
            
            sb.AppendLine("    ]");
            sb.AppendLine("  }");
            sb.AppendLine("}");
            sb.AppendLine();
        }
        
        // Outputs
        sb.AppendLine("// Outputs");
        sb.AppendLine("output vnetId string = vnet.id");
        sb.AppendLine("output vnetName string = vnet.name");
        
        // Output subnet IDs
        for (int i = 0; i < networkConfig.Subnets.Count; i++)
        {
            var subnet = networkConfig.Subnets[i];
            var outputName = subnet.Name.Replace("-", "").Replace("_", "") + "SubnetId";
            sb.AppendLine($"output {outputName} string = vnet.properties.subnets[{i}].id");
        }
        
        // Standard AKS subnet output (for compatibility)
        var aksSubnetIndex = networkConfig.Subnets.FindIndex(s => s.Name.Contains("aks") || s.Name.Contains("kubernetes"));
        if (aksSubnetIndex >= 0)
        {
            sb.AppendLine($"output aksSubnetId string = vnet.properties.subnets[{aksSubnetIndex}].id");
        }
        else if (networkConfig.Subnets.Any())
        {
            sb.AppendLine("output aksSubnetId string = vnet.properties.subnets[0].id");
        }
        
        return sb.ToString();
    }
    
    private string GenerateExistingNetworkReferencesBicep(NetworkingConfiguration networkConfig)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("// Reference Existing Network Resources for AKS");
        sb.AppendLine("// Generated by Platform Engineering Copilot");
        sb.AppendLine();
        sb.AppendLine("targetScope = 'resourceGroup'");
        sb.AppendLine();
        
        // Parameters
        sb.AppendLine("param serviceName string");
        sb.AppendLine("param environment string");
        sb.AppendLine($"param vnetName string = '{networkConfig.ExistingVNetName}'");
        sb.AppendLine($"param vnetResourceGroup string = '{networkConfig.ExistingVNetResourceGroup}'");
        sb.AppendLine("param location string = resourceGroup().location");
        sb.AppendLine("param tags object = {}");
        sb.AppendLine();
        
        // Reference existing VNet
        sb.AppendLine("// Reference existing Virtual Network");
        sb.AppendLine($"resource vnet 'Microsoft.Network/virtualNetworks@2023-05-01' existing = {{");
        sb.AppendLine($"  name: vnetName");
        sb.AppendLine($"  scope: resourceGroup(vnetResourceGroup)");
        sb.AppendLine("}");
        sb.AppendLine();
        
        // Find AKS and AppGW subnets
        var aksSubnet = networkConfig.ExistingSubnets.FirstOrDefault(s => 
            s.Purpose == SubnetPurpose.Application || s.Name.Contains("aks"));
        var appgwSubnet = networkConfig.ExistingSubnets.FirstOrDefault(s => 
            s.Purpose == SubnetPurpose.ApplicationGateway || s.Name.Contains("appgw") || s.Name.Contains("gateway"));
        
        if (aksSubnet != null)
        {
            sb.AppendLine("// Reference existing AKS subnet");
            sb.AppendLine($"resource aksSubnet 'Microsoft.Network/virtualNetworks/subnets@2023-05-01' existing = {{");
            sb.AppendLine($"  parent: vnet");
            sb.AppendLine($"  name: '{aksSubnet.Name}'");
            sb.AppendLine("}");
            sb.AppendLine();
        }
        
        if (appgwSubnet != null)
        {
            sb.AppendLine("// Reference existing Application Gateway subnet");
            sb.AppendLine($"resource appgwSubnet 'Microsoft.Network/virtualNetworks/subnets@2023-05-01' existing = {{");
            sb.AppendLine($"  parent: vnet");
            sb.AppendLine($"  name: '{appgwSubnet.Name}'");
            sb.AppendLine("}");
            sb.AppendLine();
        }
        
        // Optionally create NSG if needed
        if (networkConfig.EnableNetworkSecurityGroup && networkConfig.NsgRules.Any())
        {
            sb.AppendLine("// Network Security Group for AKS");
            sb.AppendLine($"resource nsg 'Microsoft.Network/networkSecurityGroups@2023-05-01' = {{");
            sb.AppendLine($"  name: 'nsg-${{serviceName}}-${{environment}}-aks'");
            sb.AppendLine($"  location: location");
            sb.AppendLine($"  tags: tags");
            sb.AppendLine($"  properties: {{");
            sb.AppendLine($"    securityRules: [");
            
            foreach (var rule in networkConfig.NsgRules)
            {
                sb.AppendLine($"      {{");
                sb.AppendLine($"        name: '{rule.Name}'");
                sb.AppendLine($"        properties: {{");
                sb.AppendLine($"          priority: {rule.Priority}");
                sb.AppendLine($"          direction: '{rule.Direction}'");
                sb.AppendLine($"          access: '{rule.Access}'");
                sb.AppendLine($"          protocol: '{rule.Protocol}'");
                sb.AppendLine($"          sourcePortRange: '{rule.SourcePortRange}'");
                sb.AppendLine($"          destinationPortRange: '{rule.DestinationPortRange}'");
                sb.AppendLine($"          sourceAddressPrefix: '{rule.SourceAddressPrefix}'");
                sb.AppendLine($"          destinationAddressPrefix: '{rule.DestinationAddressPrefix}'");
                sb.AppendLine($"          description: '{rule.Description}'");
                sb.AppendLine($"        }}");
                sb.AppendLine($"      }}");
            }
            
            sb.AppendLine($"    ]");
            sb.AppendLine($"  }}");
            sb.AppendLine("}");
            sb.AppendLine();
        }
        
        // Outputs
        sb.AppendLine("// Outputs");
        sb.AppendLine("output vnetId string = vnet.id");
        
        if (aksSubnet != null)
        {
            sb.AppendLine("output aksSubnetId string = aksSubnet.id");
        }
        
        if (appgwSubnet != null)
        {
            sb.AppendLine("output appgwSubnetId string = appgwSubnet.id");
        }
        
        if (networkConfig.EnableNetworkSecurityGroup && networkConfig.NsgRules.Any())
        {
            sb.AppendLine("output nsgId string = nsg.id");
        }
        
        return sb.ToString();
    }
    
    private NetworkingConfiguration CreateDefaultAKSNetworkConfig()
    {
        return new NetworkingConfiguration
        {
            Mode = NetworkMode.CreateNew,
            VNetName = "${serviceName}-${environment}-vnet",
            VNetAddressSpace = "10.0.0.0/16",
            Subnets = new List<SubnetConfiguration>
            {
                new SubnetConfiguration
                {
                    Name = "aks-subnet",
                    AddressPrefix = "10.0.0.0/20",
                    Purpose = SubnetPurpose.Application,
                    EnableServiceEndpoints = true,
                    ServiceEndpoints = new List<string>
                    {
                        "Microsoft.Storage",
                        "Microsoft.KeyVault",
                        "Microsoft.ContainerRegistry"
                    }
                },
                new SubnetConfiguration
                {
                    Name = "appgw-subnet",
                    AddressPrefix = "10.0.16.0/24",
                    Purpose = SubnetPurpose.ApplicationGateway
                },
                new SubnetConfiguration
                {
                    Name = "pe-subnet",
                    AddressPrefix = "10.0.17.0/24",
                    Purpose = SubnetPurpose.PrivateEndpoints
                }
            },
            EnableNetworkSecurityGroup = true,
            EnablePrivateEndpoint = false,
            EnableServiceEndpoints = true,
            EnableDDoSProtection = false,
            EnablePrivateDns = false
        };
    }
    
    private string GenerateIdentityBicep(TemplateGenerationRequest request)
    {
        return @"// Managed Identity Configuration for AKS
// Implements Workload Identity for pod-level authentication

targetScope = 'resourceGroup'

param serviceName string
param environment string
param location string
param enableWorkloadIdentity bool
param tags object

var identityName = '${serviceName}-${environment}-identity'

// User-Assigned Managed Identity for AKS Cluster
resource managedIdentity 'Microsoft.ManagedIdentity/userAssignedIdentities@2023-01-31' = {
  name: identityName
  location: location
  tags: tags
}

// Workload Identity for application pods
resource workloadIdentity 'Microsoft.ManagedIdentity/userAssignedIdentities@2023-01-31' = if (enableWorkloadIdentity) {
  name: '${serviceName}-${environment}-workload-identity'
  location: location
  tags: union(tags, {
    Purpose: 'WorkloadIdentity'
  })
}

// Federated Identity Credential (for Workload Identity)
// This will be created after cluster provisioning with actual OIDC issuer URL
// Example: kubectl apply -f federated-credential.yaml

output managedIdentityId string = managedIdentity.id
output managedIdentityPrincipalId string = managedIdentity.properties.principalId
output managedIdentityClientId string = managedIdentity.properties.clientId
output workloadIdentityId string = enableWorkloadIdentity ? workloadIdentity.id : ''
output workloadIdentityPrincipalId string = enableWorkloadIdentity ? workloadIdentity.properties.principalId : ''
output workloadIdentityClientId string = enableWorkloadIdentity ? workloadIdentity.properties.clientId : ''
";
    }
    
    private string GenerateMonitoringBicep(TemplateGenerationRequest request)
    {
        return @"// Azure Monitor Configuration for AKS
// Implements Container Insights and Prometheus monitoring

targetScope = 'resourceGroup'

param serviceName string
param environment string
param location string
param clusterId string
param tags object

var workspaceName = '${serviceName}-${environment}-logs'

// Log Analytics Workspace
resource workspace 'Microsoft.OperationalInsights/workspaces@2022-10-01' = {
  name: workspaceName
  location: location
  tags: tags
  properties: {
    sku: {
      name: 'PerGB2018'
    }
    retentionInDays: 30
    features: {
      enableLogAccessUsingOnlyResourcePermissions: true
    }
  }
}

// Container Insights Solution
resource containerInsights 'Microsoft.OperationsManagement/solutions@2015-11-01-preview' = {
  name: 'ContainerInsights(${workspace.name})'
  location: location
  tags: tags
  properties: {
    workspaceResourceId: workspace.id
  }
  plan: {
    name: 'ContainerInsights(${workspace.name})'
    product: 'OMSGallery/ContainerInsights'
    publisher: 'Microsoft'
    promotionCode: ''
  }
}

// Azure Monitor Workspace (for Prometheus)
resource azureMonitorWorkspace 'Microsoft.Monitor/accounts@2023-04-03' = {
  name: '${serviceName}-${environment}-monitor'
  location: location
  tags: tags
  properties: {}
}

// Data Collection Endpoint
resource dataCollectionEndpoint 'Microsoft.Insights/dataCollectionEndpoints@2022-06-01' = {
  name: '${serviceName}-${environment}-dce'
  location: location
  tags: tags
  properties: {
    networkAcls: {
      publicNetworkAccess: 'Enabled'
    }
  }
}

// Data Collection Rule (for Prometheus metrics)
resource dataCollectionRule 'Microsoft.Insights/dataCollectionRules@2022-06-01' = {
  name: '${serviceName}-${environment}-dcr'
  location: location
  tags: tags
  properties: {
    dataCollectionEndpointId: dataCollectionEndpoint.id
    dataSources: {
      prometheusForwarder: [
        {
          name: 'PrometheusDataSource'
          streams: [
            'Microsoft-PrometheusMetrics'
          ]
        }
      ]
    }
    destinations: {
      monitoringAccounts: [
        {
          accountResourceId: azureMonitorWorkspace.id
          name: 'MonitoringAccount'
        }
      ]
    }
    dataFlows: [
      {
        streams: [
          'Microsoft-PrometheusMetrics'
        ]
        destinations: [
          'MonitoringAccount'
        ]
      }
    ]
  }
}

// Diagnostic Settings for AKS
resource diagnosticSettings 'Microsoft.Insights/diagnosticSettings@2021-05-01-preview' = {
  name: '${serviceName}-${environment}-diagnostics'
  scope: resourceGroup()
  properties: {
    workspaceId: workspace.id
    logs: [
      {
        category: 'kube-apiserver'
        enabled: true
      }
      {
        category: 'kube-controller-manager'
        enabled: true
      }
      {
        category: 'kube-scheduler'
        enabled: true
      }
      {
        category: 'kube-audit'
        enabled: true
      }
      {
        category: 'guard'
        enabled: true
      }
    ]
    metrics: [
      {
        category: 'AllMetrics'
        enabled: true
      }
    ]
  }
}

output workspaceId string = workspace.id
output workspaceName string = workspace.name
output azureMonitorWorkspaceId string = azureMonitorWorkspace.id
output dataCollectionRuleId string = dataCollectionRule.id
";
    }
    
    private string GenerateSecurityBicep(TemplateGenerationRequest request)
    {
        return @"// Security Configuration - Key Vault and Policies
// Implements Azure Key Vault with Secrets Provider integration

targetScope = 'resourceGroup'

param serviceName string
param environment string
param location string
param subnetId string
param clusterPrincipalId string
param tags object

var keyVaultName = '${serviceName}-${environment}-kv'

// Azure Key Vault
resource keyVault 'Microsoft.KeyVault/vaults@2023-02-01' = {
  name: take(replace(keyVaultName, '-', ''), 24) // Key Vault names max 24 chars, no hyphens
  location: location
  tags: tags
  properties: {
    sku: {
      family: 'A'
      name: 'standard'
    }
    tenantId: subscription().tenantId
    enableRbacAuthorization: true
    enableSoftDelete: true
    softDeleteRetentionInDays: 90
    enablePurgeProtection: true
    networkAcls: {
      bypass: 'AzureServices'
      defaultAction: 'Deny'
      virtualNetworkRules: [
        {
          id: subnetId
          ignoreMissingVnetServiceEndpoint: false
        }
      ]
    }
  }
}

// Key Vault Secrets Officer role for AKS
resource keyVaultSecretsOfficer 'Microsoft.Authorization/roleAssignments@2022-04-01' = {
  name: guid(keyVault.id, clusterPrincipalId, 'Key Vault Secrets Officer')
  scope: keyVault
  properties: {
    roleDefinitionId: subscriptionResourceId('Microsoft.Authorization/roleDefinitions', 'b86a8fe4-44ce-4948-aee5-eccb2c155cd7') // Key Vault Secrets Officer
    principalId: clusterPrincipalId
    principalType: 'ServicePrincipal'
  }
}

// Example secrets (to be populated by deployment pipeline)
resource exampleSecret 'Microsoft.KeyVault/vaults/secrets@2023-02-01' = {
  parent: keyVault
  name: 'database-connection-string'
  properties: {
    value: 'placeholder-update-via-pipeline'
    contentType: 'text/plain'
  }
}

output keyVaultId string = keyVault.id
output keyVaultName string = keyVault.name
output keyVaultUri string = keyVault.properties.vaultUri
";
    }
    
    private string GenerateACRBicep(TemplateGenerationRequest request)
    {
        var serviceName = request.ServiceName.ToLowerInvariant();
        
        return $@"// Azure Container Registry Configuration
// Implements Premium tier with geo-replication and security features

targetScope = 'resourceGroup'

param serviceName string
param environment string
param location string
param clusterPrincipalId string
param enablePrivateEndpoint bool = false
param tags object

var acrName = replace('${{serviceName}}${{environment}}acr', '-', '')

// Azure Container Registry
resource acr 'Microsoft.ContainerRegistry/registries@2023-07-01' = {{
  name: take(acrName, 50) // ACR names max 50 chars
  location: location
  tags: tags
  sku: {{
    name: 'Premium'
  }}
  properties: {{
    adminUserEnabled: false
    publicNetworkAccess: enablePrivateEndpoint ? 'Disabled' : 'Enabled'
    networkRuleBypassOptions: 'AzureServices'
    zoneRedundancy: 'Enabled'
    
    // Anonymous pull (disabled for security)
    anonymousPullEnabled: false
    
    // Data endpoint (for zone redundancy)
    dataEndpointEnabled: true
    
    // Policies
    policies: {{
      quarantinePolicy: {{
        status: 'enabled'
      }}
      trustPolicy: {{
        type: 'Notary'
        status: 'enabled'
      }}
      retentionPolicy: {{
        days: 30
        status: 'enabled'
      }}
      azureADAuthenticationAsArmPolicy: {{
        status: 'enabled'
      }}
      softDeletePolicy: {{
        retentionDays: 7
        status: 'enabled'
      }}
    }}
    
    // Encryption
    encryption: {{
      status: 'disabled' // Can enable with customer-managed keys
    }}
  }}
}}

// AcrPull role for AKS kubelet identity
resource acrPullRole 'Microsoft.Authorization/roleAssignments@2022-04-01' = {{
  name: guid(acr.id, clusterPrincipalId, 'AcrPull')
  scope: acr
  properties: {{
    roleDefinitionId: subscriptionResourceId('Microsoft.Authorization/roleDefinitions', '7f951dda-4ed3-4680-a7ca-43fe172d538d') // AcrPull
    principalId: clusterPrincipalId
    principalType: 'ServicePrincipal'
  }}
}}

output loginServer string = acr.properties.loginServer
output name string = acr.name
output id string = acr.id
output acrResourceId string = acr.id
";
    }
    
    private string GenerateACRPrivateEndpointBicep(TemplateGenerationRequest request)
    {
        return @"// Private Endpoint for Azure Container Registry
// Allows ACR to be accessible only via private network

targetScope = 'resourceGroup'

param serviceName string
param environment string
param location string
param acrResourceId string
param subnetId string
param virtualNetworkId string
param tags object

var privateEndpointName = '${serviceName}-${environment}-acr-pe'
var privateDnsZoneName = 'privatelink.azurecr.io'
var pvtEndpointDnsGroupName = '${privateEndpointName}/default'

resource privateEndpoint 'Microsoft.Network/privateEndpoints@2023-05-01' = {
  name: privateEndpointName
  location: location
  tags: tags
  properties: {
    subnet: {
      id: subnetId
    }
    privateLinkServiceConnections: [
      {
        name: '${serviceName}-${environment}-acr-plsc'
        properties: {
          privateLinkServiceId: acrResourceId
          groupIds: ['registry']
        }
      }
    ]
  }
}

resource privateDnsZone 'Microsoft.Network/privateDnsZones@2020-06-01' = {
  name: privateDnsZoneName
  location: 'global'
  tags: tags
}

resource privateDnsZoneLink 'Microsoft.Network/privateDnsZones/virtualNetworkLinks@2020-06-01' = {
  parent: privateDnsZone
  name: '${serviceName}-${environment}-acr-dns-link'
  location: 'global'
  properties: {
    registrationEnabled: false
    virtualNetwork: {
      id: virtualNetworkId
    }
  }
}

resource pvtEndpointDnsGroup 'Microsoft.Network/privateEndpoints/privateDnsZoneGroups@2023-05-01' = {
  name: pvtEndpointDnsGroupName
  properties: {
    privateDnsZoneConfigs: [
      {
        name: 'config1'
        properties: {
          privateDnsZoneId: privateDnsZone.id
        }
      }
    ]
  }
  dependsOn: [
    privateEndpoint
  ]
}

output privateEndpointId string = privateEndpoint.id
output privateDnsZoneId string = privateDnsZone.id
output privateEndpointIP string = privateEndpoint.properties.customDnsConfigs[0].ipAddresses[0]
";
    }
    
    private string GenerateParametersJson(TemplateGenerationRequest request)
    {
        var serviceName = request.ServiceName.ToLowerInvariant();
        var security = request.Security ?? new SecuritySpec();
        var observability = request.Observability ?? new ObservabilitySpec();
        var infrastructure = request.Infrastructure ?? new InfrastructureSpec();
        
        // Determine intelligent defaults based on environment or request
        var isProduction = request.TemplateType?.ToLower().Contains("prod") ?? false;
        
        // Default to monitoring enabled if Prometheus or ApplicationInsights is enabled
        var enableMonitoring = observability.Prometheus || observability.ApplicationInsights;
        
        return $@"{{
  ""$schema"": ""https://schema.management.azure.com/schemas/2019-04-01/deploymentParameters.json#"",
  ""contentVersion"": ""1.0.0.0"",
  ""parameters"": {{
    ""serviceName"": {{
      ""value"": ""{serviceName}""
    }},
    ""environment"": {{
      ""value"": ""dev""
    }},
    ""location"": {{
      ""value"": ""{infrastructure.Region}""
    }},
    
    // === Security & Identity Parameters ===
    ""enablePrivateCluster"": {{
      ""value"": {isProduction.ToString().ToLower()}
    }},
    ""enableWorkloadIdentity"": {{
      ""value"": true
    }},
    ""authorizedIPRanges"": {{
      ""value"": []
    }},
    
    // === Monitoring Parameters ===
    ""enableMonitoring"": {{
      ""value"": {enableMonitoring.ToString().ToLower()}
    }},
    ""logAnalyticsWorkspaceId"": {{
      ""value"": """"
    }},
    ""enableAzurePolicy"": {{
      ""value"": true
    }},
    
    // === Cluster Configuration Parameters ===
    ""kubernetesVersion"": {{
      ""value"": ""1.30""
    }},
    ""nodeCount"": {{
      ""value"": 3
    }},
    ""nodeVmSize"": {{
      ""value"": ""Standard_D4s_v3""
    }},
    
    // === Advanced Security Parameters ===
    ""enableImageCleaner"": {{
      ""value"": true
    }},
    ""diskEncryptionSetId"": {{
      ""value"": """"
    }},
    ""enablePrivateEndpointACR"": {{
      ""value"": {isProduction.ToString().ToLower()}
    }}
  }}
}}
";
    }
    
    private string GeneratePodSecurityPolicies()
    {
        return @"# Pod Security Standards - Restricted Profile
# Enforces most restrictive security controls for Zero Trust
# Apply this to production namespaces
---
apiVersion: v1
kind: Namespace
metadata:
  name: production
  labels:
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/warn: restricted
---
apiVersion: v1
kind: Namespace
metadata:
  name: staging
  labels:
    pod-security.kubernetes.io/enforce: baseline
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/warn: restricted
---
# Example: Secure Pod with non-root user, read-only filesystem
apiVersion: v1
kind: Pod
metadata:
  name: secure-app-example
  namespace: production
spec:
  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
    fsGroup: 2000
    seccompProfile:
      type: RuntimeDefault
  containers:
  - name: app
    image: myapp:latest
    securityContext:
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      runAsNonRoot: true
      runAsUser: 1000
      capabilities:
        drop:
        - ALL
    resources:
      limits:
        cpu: ""1""
        memory: ""512Mi""
      requests:
        cpu: ""100m""
        memory: ""128Mi""
    volumeMounts:
    - name: tmp
      mountPath: /tmp
  volumes:
  - name: tmp
    emptyDir: {}
";
    }
    
    private string GenerateNetworkPolicies()
    {
        return @"# Zero Trust Network Policies
# Implements default-deny and explicit-allow micro-segmentation
---
# Default Deny All Ingress and Egress
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
  namespace: production
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress
---
# Allow DNS Resolution
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-dns
  namespace: production
spec:
  podSelector: {}
  policyTypes:
  - Egress
  egress:
  - to:
    - namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: kube-system
    - podSelector:
        matchLabels:
          k8s-app: kube-dns
    ports:
    - protocol: UDP
      port: 53
---
# Allow Frontend to Backend Communication
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-frontend-to-backend
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: backend
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: frontend
    ports:
    - protocol: TCP
      port: 8080
---
# Allow Backend to Database
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-backend-to-database
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: database
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: backend
    ports:
    - protocol: TCP
      port: 5432
---
# Allow Ingress Controller Traffic
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-ingress-controller
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: frontend
  policyTypes:
  - Ingress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: ingress-nginx
    ports:
    - protocol: TCP
      port: 80
    - protocol: TCP
      port: 443
---
# Allow Egress to Azure Services (Key Vault, Storage, etc.)
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-azure-services
  namespace: production
spec:
  podSelector:
    matchLabels:
      azure-service-access: enabled
  policyTypes:
  - Egress
  egress:
  - to:
    - podSelector: {}
    ports:
    - protocol: TCP
      port: 443
";
    }
    
    private string GenerateAzurePolicyAssignments()
    {
        return @"// Azure Policy Assignments for AKS - Zero Trust Compliance
// Enforces security, compliance, and operational best practices
targetScope = 'resourceGroup'

param clusterName string
param location string

// Reference the AKS cluster
resource aksCluster 'Microsoft.ContainerService/managedClusters@2023-10-01' existing = {
  name: clusterName
}

// Policy: Kubernetes cluster containers should only use allowed images
resource allowedContainerImagesPolicy 'Microsoft.Authorization/policyAssignments@2023-04-01' = {
  name: 'aks-allowed-images-${clusterName}'
  location: location
  properties: {
    policyDefinitionId: '/providers/Microsoft.Authorization/policyDefinitions/febd0533-8e55-448f-b837-bd0e06f16469'
    parameters: {
      excludedNamespaces: {
        value: [
          'kube-system'
          'gatekeeper-system'
          'azure-arc'
        ]
      }
      namespaces: {
        value: []
      }
      labelSelector: {
        value: {}
      }
      allowedContainerImagesRegex: {
        value: '^.+\\\\.azurecr\\\\.io/.+$|^mcr\\\\.microsoft\\\\.com/.+$'
      }
    }
    displayName: 'Allowed Container Images (ACR and MCR only)'
    description: 'Restricts container images to approved registries'
  }
  identity: {
    type: 'SystemAssigned'
  }
}

// Policy: Do not allow privileged containers
resource noPrivilegedContainersPolicy 'Microsoft.Authorization/policyAssignments@2023-04-01' = {
  name: 'aks-no-priv-containers-${take(clusterName, 40)}'
  location: location
  properties: {
    policyDefinitionId: '/providers/Microsoft.Authorization/policyDefinitions/95edb821-ddaf-4404-9732-666045e056b4'
    parameters: {
      excludedNamespaces: {
        value: [
          'kube-system'
          'gatekeeper-system'
        ]
      }
    }
    displayName: 'Do not allow privileged containers'
    description: 'Prevents privilege escalation attacks'
  }
  identity: {
    type: 'SystemAssigned'
  }
}

// Policy: Enforce HTTPS ingress
resource httpsIngressPolicy 'Microsoft.Authorization/policyAssignments@2023-04-01' = {
  name: 'aks-https-ingress-${take(clusterName, 47)}'
  location: location
  properties: {
    policyDefinitionId: '/providers/Microsoft.Authorization/policyDefinitions/1a5b4dca-0b6f-4cf5-907c-56316bc1bf3d'
    parameters: {
      excludedNamespaces: {
        value: [
          'kube-system'
        ]
      }
    }
    displayName: 'Enforce HTTPS ingress'
    description: 'Ensures all ingress uses HTTPS/TLS'
  }
  identity: {
    type: 'SystemAssigned'
  }
}

// Policy: Enforce internal load balancers
resource internalLoadBalancerPolicy 'Microsoft.Authorization/policyAssignments@2023-04-01' = {
  name: 'aks-internal-lb-${take(clusterName, 50)}'
  location: location
  properties: {
    policyDefinitionId: '/providers/Microsoft.Authorization/policyDefinitions/3fc4dc25-5baf-40d8-9b05-7fe74c1bc64e'
    parameters: {
      excludedNamespaces: {
        value: [
          'kube-system'
          'ingress-nginx'
        ]
      }
    }
    displayName: 'Enforce internal load balancers'
    description: 'Prevents public load balancers except in allowed namespaces'
  }
  identity: {
    type: 'SystemAssigned'
  }
}

// Policy: Containers must use allowed AppArmor profiles
resource appArmorPolicy 'Microsoft.Authorization/policyAssignments@2023-04-01' = {
  name: 'aks-apparmor-${take(clusterName, 54)}'
  location: location
  properties: {
    policyDefinitionId: '/providers/Microsoft.Authorization/policyDefinitions/511f5417-5d12-434d-ab2e-816901e72a5e'
    parameters: {
      excludedNamespaces: {
        value: [
          'kube-system'
        ]
      }
      allowedProfiles: {
        value: [
          'runtime/default'
          'docker/default'
        ]
      }
    }
    displayName: 'Enforce AppArmor profiles'
    description: 'Restricts containers to approved AppArmor security profiles'
  }
  identity: {
    type: 'SystemAssigned'
  }
}

// Policy: Container CPU and memory limits
resource resourceLimitsPolicy 'Microsoft.Authorization/policyAssignments@2023-04-01' = {
  name: 'aks-resource-limits-${take(clusterName, 47)}'
  location: location
  properties: {
    policyDefinitionId: '/providers/Microsoft.Authorization/policyDefinitions/e345eecc-fa47-480f-9e88-67dcc122b164'
    parameters: {
      excludedNamespaces: {
        value: [
          'kube-system'
          'gatekeeper-system'
        ]
      }
      cpuLimit: {
        value: '2000m'
      }
      memoryLimit: {
        value: '4Gi'
      }
    }
    displayName: 'Enforce resource limits'
    description: 'Prevents resource exhaustion attacks'
  }
  identity: {
    type: 'SystemAssigned'
  }
}

// Policy: Read-only root filesystem
resource readOnlyRootFSPolicy 'Microsoft.Authorization/policyAssignments@2023-04-01' = {
  name: 'aks-readonly-rootfs-${take(clusterName, 46)}'
  location: location
  properties: {
    policyDefinitionId: '/providers/Microsoft.Authorization/policyDefinitions/df49d893-a74c-421d-bc95-c663042e5b80'
    parameters: {
      excludedNamespaces: {
        value: [
          'kube-system'
        ]
      }
      excludedContainers: {
        value: []
      }
    }
    displayName: 'Enforce read-only root filesystem'
    description: 'Prevents runtime file system tampering'
  }
  identity: {
    type: 'SystemAssigned'
  }
}

output policyAssignmentIds array = [
  allowedContainerImagesPolicy.id
  noPrivilegedContainersPolicy.id
  httpsIngressPolicy.id
  internalLoadBalancerPolicy.id
  appArmorPolicy.id
  resourceLimitsPolicy.id
  readOnlyRootFSPolicy.id
]
";
    }
}
